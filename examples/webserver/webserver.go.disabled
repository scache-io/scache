package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/scache-io/scache/cache"
)

// Response APIå“åº”ç»“æ„
type Response struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// CacheStatsResponse ç¼“å­˜ç»Ÿè®¡å“åº”
type CacheStatsResponse struct {
	Hits    int64    `json:"hits"`
	Misses  int64    `json:"misses"`
	Sets    int64    `json:"sets"`
	Deletes int64    `json:"deletes"`
	Size    int      `json:"size"`
	MaxSize int      `json:"max_size"`
	HitRate float64  `json:"hit_rate"`
	Keys    []string `json:"keys,omitempty"`
}

var (
	appCache      *cache.MemoryCache
	indexTemplate *template.Template
)

// loadTemplates åŠ è½½HTMLæ¨¡æ¿
func loadTemplates() error {
	// å°è¯•å¤šä¸ªå¯èƒ½çš„æ¨¡æ¿è·¯å¾„
	templatePaths := []string{
		"./index.html",                    // ä»webserverç›®å½•è¿è¡Œ
		"./examples/webserver/index.html", // ä»é¡¹ç›®æ ¹ç›®å½•è¿è¡Œ
		"index.html",                      // ç›¸å¯¹è·¯å¾„
	}

	var templatePath string
	var err error

	// æŸ¥æ‰¾å­˜åœ¨çš„æ¨¡æ¿æ–‡ä»¶
	for _, path := range templatePaths {
		if _, err = os.Stat(path); err == nil {
			templatePath = path
			break
		}
	}

	// å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œå°è¯•ä»æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•æŸ¥æ‰¾
	if templatePath == "" {
		exePath, exeErr := os.Executable()
		if exeErr != nil {
			return fmt.Errorf("è·å–æ‰§è¡Œè·¯å¾„å¤±è´¥: %w", exeErr)
		}
		exeDir := filepath.Dir(exePath)
		templatePath = filepath.Join(exeDir, "index.html")
		if _, err = os.Stat(templatePath); err != nil {
			return fmt.Errorf("æœªæ‰¾åˆ°æ¨¡æ¿æ–‡ä»¶ï¼Œå°è¯•çš„è·¯å¾„: %v", templatePaths)
		}
	}

	templateContent, err := os.ReadFile(templatePath)
	if err != nil {
		return fmt.Errorf("è¯»å–æ¨¡æ¿æ–‡ä»¶å¤±è´¥: %w", err)
	}

	indexTemplate, err = template.New("index").Parse(string(templateContent))
	if err != nil {
		return fmt.Errorf("è§£ææ¨¡æ¿å¤±è´¥: %w", err)
	}

	log.Printf("âœ… æ¨¡æ¿åŠ è½½æˆåŠŸ: %s", templatePath)
	return nil
}

// setCORS è®¾ç½®CORSå¤´ï¼Œæ”¯æŒè¿œç¨‹è°ƒç”¨
func setCORS(w http.ResponseWriter) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
	w.Header().Set("Access-Control-Max-Age", "86400")
}

// withCORS CORSä¸­é—´ä»¶
func withCORS(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		setCORS(w)

		// å¤„ç†é¢„æ£€è¯·æ±‚
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next(w, r)
	}
}

func main() {
	fmt.Println("=== ç¼“å­˜WebæœåŠ¡ç¤ºä¾‹ ===")

	// åˆå§‹åŒ–åº”ç”¨ç¼“å­˜
	c := cache.NewCache(
		cache.WithMaxSize(1000),
		cache.WithDefaultExpiration(time.Minute*30),
		cache.WithMemoryThreshold(0.7),             // 70%å†…å­˜é˜ˆå€¼
		cache.WithBackgroundCleanup(time.Minute*2), // åå°æ¸…ç†2åˆ†é’Ÿé—´éš”
	)
	appCache = c.(*cache.MemoryCache)

	// åŠ è½½HTMLæ¨¡æ¿
	if err := loadTemplates(); err != nil {
		log.Printf("è­¦å‘Š: åŠ è½½æ¨¡æ¿å¤±è´¥: %v", err)
	}

	// è®¾ç½®è·¯ç”± - ä½¿ç”¨CORSä¸­é—´ä»¶
	http.HandleFunc("/", withCORS(handleHome))
	http.HandleFunc("/index.html", withCORS(handleHome)) // æ”¯æŒç›´æ¥è®¿é—®æ¨¡æ¿æ–‡ä»¶
	http.HandleFunc("/api/cache/set", withCORS(handleSet))
	http.HandleFunc("/api/cache/setlist", withCORS(handleSetList))
	http.HandleFunc("/api/cache/get", withCORS(handleGet))
	http.HandleFunc("/api/cache/delete", withCORS(handleDelete))
	http.HandleFunc("/api/cache/exists", withCORS(handleExists))
	http.HandleFunc("/api/cache/flush", withCORS(handleFlush))
	http.HandleFunc("/api/cache/stats", withCORS(handleStats))
	http.HandleFunc("/api/cache/keys", withCORS(handleKeys))
	http.HandleFunc("/api/cache/keys/page", withCORS(handleKeysPage))
	http.HandleFunc("/api/cache/size", withCORS(handleSize))

	fmt.Println("\nğŸš€ WebæœåŠ¡å¯åŠ¨åœ¨ http://localhost:8080")
	fmt.Println("\nâœ… æ”¯æŒåŠŸèƒ½:")
	fmt.Println("  ğŸŒ CORSè·¨åŸŸè°ƒç”¨æ”¯æŒ")
	fmt.Println("  ğŸ“± å“åº”å¼Webç•Œé¢")
	fmt.Println("  ğŸ§ª åœ¨çº¿APIæµ‹è¯•")
	fmt.Println("  ğŸ“Š å®æ—¶ç›‘æ§é¢æ¿")
	fmt.Println("\nğŸ“‹ å¯ç”¨çš„APIç«¯ç‚¹:")
	fmt.Println("  GET  /                    - ä¸»é¡µå’ŒAPIè¯´æ˜")
	fmt.Println("  POST /api/cache/set      - è®¾ç½®ç¼“å­˜é¡¹")
	fmt.Println("  POST /api/cache/setlist   - æ‰¹é‡è®¾ç½®ç¼“å­˜é¡¹")
	fmt.Println("  GET  /api/cache/get      - è·å–ç¼“å­˜é¡¹")
	fmt.Println("  DELETE /api/cache/delete - åˆ é™¤ç¼“å­˜é¡¹")
	fmt.Println("  GET  /api/cache/exists   - æ£€æŸ¥ç¼“å­˜é¡¹æ˜¯å¦å­˜åœ¨")
	fmt.Println("  POST /api/cache/flush    - æ¸…ç©ºç¼“å­˜")
	fmt.Println("  GET  /api/cache/stats    - è·å–ç¼“å­˜ç»Ÿè®¡")
	fmt.Println("  GET  /api/cache/keys     - è·å–æ‰€æœ‰é”®")
	fmt.Println("  GET  /api/cache/keys/page?page=1&size=10 - åˆ†é¡µè·å–é”®")
	fmt.Println("  GET  /api/cache/size     - è·å–ç¼“å­˜å¤§å°")
	fmt.Println("\nğŸ”— è¿œç¨‹è°ƒç”¨ç¤ºä¾‹:")
	fmt.Println("  curl -X POST http://localhost:8080/api/cache/set \\")
	fmt.Println("    -H \"Content-Type: application/json\" \\")
	fmt.Println("    -d '{\"key\":\"test\",\"value\":\"è¿œç¨‹è°ƒç”¨æµ‹è¯•\"}'")

	log.Fatal(http.ListenAndServe(":8080", nil))
}

func handleHome(w http.ResponseWriter, r *http.Request) {
	// è®¾ç½®CORSå¤´ï¼Œæ”¯æŒè¿œç¨‹è°ƒç”¨
	setCORS(w)

	// åªå¤„ç†æ ¹è·¯å¾„å’Œindex.html
	if r.URL.Path != "/" && r.URL.Path != "/index.html" {
		http.NotFound(w, r)
		return
	}

	// å¦‚æœæ¨¡æ¿åŠ è½½æˆåŠŸï¼Œä½¿ç”¨æ¨¡æ¿ï¼›å¦åˆ™è¿”å›ç®€å•çš„HTMLå“åº”
	if indexTemplate != nil {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := indexTemplate.Execute(w, nil); err != nil {
			log.Printf("æ¨¡æ¿æ‰§è¡Œå¤±è´¥: %v", err)
			http.Error(w, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯", http.StatusInternalServerError)
		}
	} else {
		// å¤‡ç”¨ç®€å•å“åº”
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		fmt.Fprint(w, `<!DOCTYPE html>
<html>
<head>
    <title>ç¼“å­˜WebæœåŠ¡</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .error { color: #dc3545; background: #f8d7da; padding: 15px; border-radius: 5px; }
        .endpoint { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .method { font-weight: bold; color: #007bff; }
        pre { background: #fff; border-left: 3px solid #007bff; padding: 10px; }
    </style>
</head>
<body>
    <h1>ğŸš€ ç¼“å­˜WebæœåŠ¡</h1>
    <div class="error">
        <strong>æ³¨æ„:</strong> HTMLæ¨¡æ¿æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œæ­£åœ¨ä½¿ç”¨ç®€åŒ–ç•Œé¢ã€‚
        <br>è¯·ç¡®ä¿ index.html æ–‡ä»¶åœ¨ç¨‹åºç›®å½•ä¸­ã€‚
    </div>

    <h2>ğŸ“‹ å¯ç”¨çš„APIç«¯ç‚¹</h2>
    <div class="endpoint"><span class="method">GET</span> /api/cache/stats - è·å–ç¼“å­˜ç»Ÿè®¡</div>
    <div class="endpoint"><span class="method">POST</span> /api/cache/set - è®¾ç½®ç¼“å­˜é¡¹</div>
    <div class="endpoint"><span class="method">GET</span> /api/cache/get - è·å–ç¼“å­˜é¡¹</div>
    <div class="endpoint"><span class="method">DELETE</span> /api/cache/delete - åˆ é™¤ç¼“å­˜é¡¹</div>
    <div class="endpoint"><span class="method">GET</span> /api/cache/exists - æ£€æŸ¥ç¼“å­˜é¡¹æ˜¯å¦å­˜åœ¨</div>
    <div class="endpoint"><span class="method">POST</span> /api/cache/flush - æ¸…ç©ºç¼“å­˜</div>
    <div class="endpoint"><span class="method">GET</span> /api/cache/keys - è·å–æ‰€æœ‰é”®</div>
    <div class="endpoint"><span class="method">GET</span> /api/cache/size - è·å–ç¼“å­˜å¤§å°</div>

    <p>âœ… æœåŠ¡å·²å¯åŠ¨å¹¶æ”¯æŒCORSè¿œç¨‹è°ƒç”¨ï¼</p>
</body>
</html>`)
	}
}

func handleSet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		sendError(w, "åªæ”¯æŒPOSTæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Key   string `json:"key"`
		Value string `json:"value"`
		TTL   string `json:"ttl,omitempty"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendError(w, "æ— æ•ˆçš„JSONæ ¼å¼", http.StatusBadRequest)
		return
	}

	if req.Key == "" {
		sendError(w, "é”®ä¸èƒ½ä¸ºç©º", http.StatusBadRequest)
		return
	}

	// è§£æTTL
	var ttl time.Duration
	if req.TTL != "" {
		var err error
		ttl, err = time.ParseDuration(req.TTL)
		if err != nil {
			sendError(w, "æ— æ•ˆçš„TTLæ ¼å¼", http.StatusBadRequest)
			return
		}
	}

	if err := appCache.Set(req.Key, req.Value, ttl); err != nil {
		sendError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	sendResponse(w, true, "ç¼“å­˜è®¾ç½®æˆåŠŸ", "")
}

func handleGet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	key := r.URL.Query().Get("key")
	if key == "" {
		sendError(w, "é”®å‚æ•°æ˜¯å¿…éœ€çš„", http.StatusBadRequest)
		return
	}

	value, found := appCache.Get(key)
	if !found {
		sendError(w, "ç¼“å­˜é¡¹æœªæ‰¾åˆ°", http.StatusNotFound)
		return
	}

	sendResponse(w, true, value, "")
}

func handleDelete(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodDelete {
		sendError(w, "åªæ”¯æŒDELETEæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	key := r.URL.Query().Get("key")
	if key == "" {
		sendError(w, "é”®å‚æ•°æ˜¯å¿…éœ€çš„", http.StatusBadRequest)
		return
	}

	if appCache.Delete(key) {
		sendResponse(w, true, "", "ç¼“å­˜åˆ é™¤æˆåŠŸ")
	} else {
		sendError(w, "ç¼“å­˜é¡¹æœªæ‰¾åˆ°", http.StatusNotFound)
	}
}

func handleExists(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	key := r.URL.Query().Get("key")
	if key == "" {
		sendError(w, "é”®å‚æ•°æ˜¯å¿…éœ€çš„", http.StatusBadRequest)
		return
	}

	exists := appCache.Exists(key)
	sendResponse(w, true, map[string]bool{"exists": exists}, "")
}

func handleFlush(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		sendError(w, "åªæ”¯æŒPOSTæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	appCache.Flush()
	sendResponse(w, true, "", "ç¼“å­˜å·²æ¸…ç©º")
}

func handleStats(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	stats := appCache.Stats()
	response := CacheStatsResponse{
		Hits:    stats.Hits,
		Misses:  stats.Misses,
		Sets:    stats.Sets,
		Deletes: stats.Deletes,
		Size:    stats.Size,
		MaxSize: stats.MaxSize,
		HitRate: stats.HitRate,
	}

	// æ·»åŠ é”®åˆ—è¡¨
	response.Keys = appCache.Keys()

	sendResponse(w, true, response, "")
}

func handleKeys(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	keys := appCache.Keys()
	sendResponse(w, true, keys, "")
}

func handleSize(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	size := appCache.Size()
	sendResponse(w, true, map[string]int{"size": size}, "")
}

func sendResponse(w http.ResponseWriter, success bool, data interface{}, message string) {
	w.Header().Set("Content-Type", "application/json")

	response := Response{
		Success: success,
		Data:    data,
	}

	if message != "" && success {
		response.Data = map[string]interface{}{"message": message, "data": data}
	}

	json.NewEncoder(w).Encode(response)
}

func sendError(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	response := Response{
		Success: false,
		Error:   message,
	}

	json.NewEncoder(w).Encode(response)
}

func handleSetList(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		sendError(w, "åªæ”¯æŒPOSTæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Key   string        `json:"key"`
		Value []interface{} `json:"value"`
		TTL   string        `json:"ttl,omitempty"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendError(w, "æ— æ•ˆçš„JSONæ ¼å¼", http.StatusBadRequest)
		return
	}

	if req.Key == "" {
		sendError(w, "keyå­—æ®µä¸èƒ½ä¸ºç©º", http.StatusBadRequest)
		return
	}

	if req.Value == nil {
		sendError(w, "valueå­—æ®µä¸èƒ½ä¸ºç©º", http.StatusBadRequest)
		return
	}

	// è§£æTTL
	var ttl time.Duration
	if req.TTL != "" {
		var err error
		ttl, err = time.ParseDuration(req.TTL)
		if err != nil {
			sendError(w, "æ— æ•ˆçš„TTLæ ¼å¼", http.StatusBadRequest)
			return
		}
	}

	err := appCache.SetList(req.Key, req.Value, ttl)
	if err != nil {
		sendError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	sendResponse(w, true, map[string]interface{}{"message": "æ‰¹é‡è®¾ç½®æˆåŠŸ"}, "")
}

func handleKeysPage(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		sendError(w, "åªæ”¯æŒGETæ–¹æ³•", http.StatusMethodNotAllowed)
		return
	}

	pageStr := r.URL.Query().Get("page")
	sizeStr := r.URL.Query().Get("size")

	page := 1
	size := 10

	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	if sizeStr != "" {
		if s, err := strconv.Atoi(sizeStr); err == nil && s > 0 {
			size = s
		}
	}

	pageResult := appCache.KeysPage(page, size)
	sendResponse(w, true, pageResult, "")
}
