package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"

	"github.com/scache-io/scache"
)

func main() {
	fmt.Println("=== 并发缓存测试示例 ===")

	// 创建缓存实例
	c := scache.New(
		config.WithMaxSize(1000),
		config.WithDefaultExpiration(time.Minute*5),
	)

	var wg sync.WaitGroup
	numWorkers := 50
	operationsPerWorker := 100

	fmt.Printf("\n启动 %d 个协程，每个协程执行 %d 次操作\n", numWorkers, operationsPerWorker)

	startTime := time.Now()

	// 启动多个写协程
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			for j := 0; j < operationsPerWorker; j++ {
				key := fmt.Sprintf("worker:%d:key:%d", workerID, j)
				value := fmt.Sprintf("value-%d-%d", workerID, j)

				// 随机TTL
				ttl := time.Duration(rand.Intn(300)) * time.Second
				c.Set(key, value, ttl)
			}
		}(i)
	}

	// 启动多个读协程
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			for j := 0; j < operationsPerWorker; j++ {
				key := fmt.Sprintf("worker:%d:key:%d", workerID, j)
				c.Get(key)
			}
		}(i)
	}

	// 启动混合操作协程
	for i := 0; i < numWorkers/2; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			for j := 0; j < operationsPerWorker; j++ {
				// 随机选择操作类型
				operation := rand.Intn(3)
				key := fmt.Sprintf("mixed:%d:key:%d", workerID, j)

				switch operation {
				case 0: // 设置
					value := fmt.Sprintf("mixed-value-%d-%d", workerID, j)
					c.Set(key, value, time.Minute)
				case 1: // 获取
					c.Get(key)
				case 2: // 删除
					c.Delete(key)
				}
			}
		}(i)
	}

	// 等待所有操作完成
	wg.Wait()
	duration := time.Since(startTime)

	fmt.Printf("\n所有操作完成，耗时: %v\n", duration)

	// 显示最终统计
	stats := c.Stats()
	fmt.Printf("\n=== 性能统计 ===\n")
	fmt.Printf("总设置次数: %d\n", stats.Sets)
	fmt.Printf("总命中次数: %d\n", stats.Hits)
	fmt.Printf("总未命中次数: %d\n", stats.Misses)
	fmt.Printf("总删除次数: %d\n", stats.Deletes)
	fmt.Printf("命中率: %.2f%%\n", stats.HitRate*100)
	fmt.Printf("最终缓存大小: %d\n", stats.Size)
	fmt.Printf("最大容量: %d\n", stats.MaxSize)

	// 计算吞吐量
	totalOperations := numWorkers*operationsPerWorker*2 + (numWorkers/2)*operationsPerWorker
	throughput := float64(totalOperations) / duration.Seconds()
	fmt.Printf("总操作数: %d\n", totalOperations)
	fmt.Printf("吞吐量: %.2f ops/sec\n", throughput)

	// 测试并发安全性
	fmt.Println("\n=== 并发安全性测试 ===")
	testConcurrentSafety(c)
}

func testConcurrentSafety(c interface{}) {
	// 类型断言
	cache, ok := c.(interface {
		Set(key string, value interface{}, ttl time.Duration) error
		Get(key string) (interface{}, bool)
		Delete(key string) bool
	})
	if !ok {
		fmt.Println("❌ 缓存类型不支持所需接口")
		return
	}

	var wg sync.WaitGroup
	errors := make(chan error, 100)
	done := make(chan bool, 1)

	// 错误收集协程
	go func() {
		errorCount := 0
		for err := range errors {
			fmt.Printf("错误: %v\n", err)
			errorCount++
		}
		if errorCount == 0 {
			fmt.Println("✅ 并发安全性测试通过，未发现错误")
		} else {
			fmt.Printf("❌ 发现 %d 个错误\n", errorCount)
		}
		done <- true
	}()

	// 并发读写测试
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			for j := 0; j < 10; j++ {
				key := fmt.Sprintf("safety:%d:%d", id, j)

				// 设置
				if err := cache.Set(key, id, 0); err != nil {
					errors <- fmt.Errorf("设置错误 %s: %v", key, err)
					return
				}

				// 获取
				if value, found := cache.Get(key); found {
					if value != id {
						errors <- fmt.Errorf("数据不一致 %s: 期望 %d, 得到 %v", key, id, value)
						return
					}
				}

				// 删除
				cache.Delete(key)
			}
		}(i)
	}

	wg.Wait()
	close(errors)
	<-done
}
