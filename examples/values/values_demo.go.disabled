package main

import (
	"fmt"
	"log"
	"time"

	"github.com/scache-io/scache/values"
)

func main() {
	fmt.Println("=== Values包演示 ===")

	// 1. 创建处理器
	processor := values.NewDefaultProcessor()
	fmt.Println("✅ 值处理器创建成功")

	// 2. 处理不同类型的值
	fmt.Println("\n2. 处理不同类型的值")

	// 字符串
	strResult, err := processor.ProcessValue("Hello World", 0)
	if err != nil {
		log.Printf("字符串处理失败: %v", err)
	} else {
		fmt.Printf("字符串: 大小=%d字节, TTL=%v\n",
			strResult.Size,
			values.FormatTTL(strResult.TTL))
	}

	// 数字
	numResult, err := processor.ProcessValue(42, 0)
	if err != nil {
		log.Printf("数字处理失败: %v", err)
	} else {
		fmt.Printf("数字: 大小=%d字节, TTL=%v\n",
			numResult.Size,
			values.FormatTTL(numResult.TTL))
	}

	// 布尔值
	boolResult, err := processor.ProcessValue(true, 0)
	if err != nil {
		log.Printf("布尔值处理失败: %v", err)
	} else {
		fmt.Printf("布尔值: 大小=%d字节, TTL=%v\n",
			boolResult.Size,
			values.FormatTTL(boolResult.TTL))
	}

	// 数组 (SetList类型)
	arrayResult, err := processor.ProcessValue([]interface{}{1, 2, 3, "hello", true}, 0)
	if err != nil {
		log.Printf("数组处理失败: %v", err)
	} else {
		fmt.Printf("数组: 大小=%d字节, TTL=%v\n",
			arrayResult.Size,
			values.FormatTTL(arrayResult.TTL))
	}

	// 3. 大数组TTL动态调整
	fmt.Println("\n3. 大数组TTL动态调整")
	smallArray := make([]interface{}, 5)
	smallResult, _ := processor.ProcessValue(smallArray, 0)
	fmt.Printf("小数组(5个元素): TTL=%v\n", values.FormatTTL(smallResult.TTL))

	mediumArray := make([]interface{}, 20)
	mediumResult, _ := processor.ProcessValue(mediumArray, 0)
	fmt.Printf("中数组(20个元素): TTL=%v\n", values.FormatTTL(mediumResult.TTL))

	largeArray := make([]interface{}, 150)
	largeResult, _ := processor.ProcessValue(largeArray, 0)
	fmt.Printf("大数组(150个元素): TTL=%v\n", values.FormatTTL(largeResult.TTL))

	// 4. 自定义处理器注册
	fmt.Println("\n4. 自定义处理器")

	// 注册用户自定义处理器
	userHandler := &UserHandler{}
	values.RegisterHandler("user", userHandler)

	type User struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
		Age  int    `json:"age"`
	}

	user := User{ID: 1, Name: "张三", Age: 25}
	userResult, err := processor.ProcessValue(user, 0)
	if err != nil {
		log.Printf("用户对象处理失败: %v", err)
	} else {
		fmt.Printf("用户对象: 大小=%d字节, TTL=%v\n",
			userResult.Size,
			values.FormatTTL(userResult.TTL))
	}

	// 5. 值验证
	fmt.Println("\n5. 值验证")
	testValues := []interface{}{
		"valid string",
		123,
		true,
		[]interface{}{1, 2, 3},
		nil, // 会失败
	}

	for i, val := range testValues {
		err := values.ValidateValue(val)
		if err != nil {
			fmt.Printf("值 %d: 验证失败 - %v\n", i+1, err)
		} else {
			fmt.Printf("值 %d: 验证通过\n", i+1)
		}
	}

	// 6. 值大小估算
	fmt.Println("\n6. 值大小估算")
	sizeExamples := []interface{}{
		"short",
		"this is a much longer string for testing size estimation",
		42,
		true,
		[]interface{}{1, 2, 3, 4, 5},
		map[string]interface{}{"key1": "value1", "key2": 123},
	}

	for i, val := range sizeExamples {
		size := values.GetSize(val)
		valType := values.GetValueType(val)
		fmt.Printf("值 %d (%s): %d字节\n", i+1, valType, size)
	}

	// 7. 值序列化测试
	fmt.Println("\n7. 值序列化测试")
	testValue := "Hello World"
	if handler, exists := processor.GetHandler(testValue); exists {
		if serializer, ok := handler.(values.Serializer); ok {
			data, err := serializer.Serialize(testValue)
			if err != nil {
				log.Printf("序列化失败: %v", err)
			} else {
				fmt.Printf("原始值: %v\n", testValue)
				fmt.Printf("序列化数据: %s\n", string(data))

				// 反序列化
				restored, err := serializer.Deserialize(data)
				if err != nil {
					log.Printf("反序列化失败: %v", err)
				} else {
					fmt.Printf("反序列化结果: %v\n", restored)
				}
			}
		}
	}

	fmt.Println("\n=== Values包演示完成 ===")
}

// UserHandler 用户对象处理器示例
type UserHandler struct{}

func (h *UserHandler) Validate(value interface{}) error {
	// 这里可以添加用户对象的验证逻辑
	return nil
}

func (h *UserHandler) Serialize(value interface{}) ([]byte, error) {
	// 这里可以添加用户对象的自定义序列化逻辑
	return nil, nil
}

func (h *UserHandler) Deserialize(data []byte) (interface{}, error) {
	// 这里可以添加用户对象的自定义反序列化逻辑
	return nil, nil
}

func (h *UserHandler) GetSize(value interface{}) int {
	// 用户对象通常包含ID、姓名、年龄等，估算64字节
	return 64
}

func (h *UserHandler) GetTTL(value interface{}) time.Duration {
	// 用户信息缓存时间较长，因为不经常变化
	return time.Hour * 24
}
